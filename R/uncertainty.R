###########################################################
# UNCERTAINTY
#
# xxxxxxx
#
###########################################################

# ---------------------------------------------------------
# Parent function for generating uncertainty
# Called by: launch.R, main.R (and other launch-style scripts)
# ---------------------------------------------------------
run_uncertainty = function() {
  
  # Only continue if specified by do_step
  if (!is.element(3, o$do_step)) return()
  
  message("* Generating uncertainty")
  
  # Load tables up front (see db_utils.R)
  load_tables("wpp_input")
  
  # Load impact factors calculated in step 2
  impact_dt       = try_load(o$pth$impact_factors, "impact_dt")
  scenario_impact = try_load(o$pth$impact_factors, "scenario_impact")
  
  # ---- Draws for VIMC diseases ----
  
  message(" - VIMC diseases")
  
  # NOTE: Do we not need to consider activity_type here? As raking is vaccine-activity combo.
  raking_dt = summarize_raking(impact_dt) %>%
    select(vaccine, cv)
  
  # Append or calculate (using cv) standard deviation for all VIMC diseases
  #
  # NOTE: vimc_ui generated by data-raw/prep_vimc_ui.R
  vimc_dt = vimc_ui %>%
    right_join(y  = scenario_impact$dt,  # Join impact factor
               by = c("disease", "location_id", "year")) %>%
    filter(disease %in% o$disease$vimc) %>%  # VIMC diseases only
    left_join(raking_dt, by = "vaccine") %>%
    mutate(sd = ifelse(is.na(sd), deaths_averted * cv, sd)) %>%  # ?? Imputing missing values (for non-VIMC countries) ??
    select(disease, location_id, vaccine, activity_type, 
           impact_factor, year, age, fvps, deaths_averted, sd)
  
  # Generate uncertainty 
  vimc_draws = generate_vimc_uncertainty(vimc_dt)

  # ---- Draws for non-VIMC diseases ----
  
  message(" - GBD diseases")
  
  # Generate draws for non-VIMC diseases using CI of initial vaccine efficacy
  #
  # NOTE: gbd_efficacy generated by data-raw/gbd_efficacy.R
  gbd_dt = gbd_efficacy %>%
    filter(disease %in% o$disease$gbd) %>%
    select(-source)
  
  gbd_draws = generate_gbd_uncertainty(gbd_dt, scenario_impact)
  
  # ---- Combine and rescale to the mean ----
  
  message(" - Combining draws")
  
  # Concatenate the two datatables
  draws_dt = rbind(gbd_draws, vimc_draws)
  
  draws_dt[, draw_mean := rowMeans(draws_dt[, grep("draw", names(draws_dt), value = T), with = F])]
  draws_dt[, mean_diff := deaths_averted - draw_mean]
  draws_dt[, grep("draw", names(draws_dt), value = T) := draws_dt[, grep("draw", names(draws_dt), value = T), with = F] + mean_diff]
  draws_dt[, c("draw_mean", "mean_diff") := NULL]
  
  year_total_draws <- draws_dt[, lapply(.SD, sum), by = .(year), .SDcols = paste0("draw_", 1:200)]
  melt_year_total_draws <- melt(year_total_draws, id.vars = "year")
  year_total_summary <- melt_year_total_draws[, .(mean = mean(value), 
                                                  lower = quantile(value, 0.05), upper = quantile(value, 0.95)),
                                              by = year]

  # Diagnostic plot
  # ggplot(year_total_summary, aes(x = year)) + 
  #   geom_ribbon(aes(ymin = lower, ymax = upper), 
  #               colour = "red", fill = "red", alpha = 0.5) + 
  #   geom_line(aes(y = mean), colour = "red", linewidth = 2) + 
  #   geom_point(data = scenario_impact$year_totals,
  #              mapping = aes(y = total), 
  #              colour = "black")
  
  message(" - Saving results")
  
  ## Save for sharing
  out_dt <- merge(
    draws_dt,
    loc_table[, .(location_id, location_name, location_iso3, region, income_group, gavi73)],
    by = "location_id"
  )
  out_dt <- out_dt[order(location_name, disease, vaccine, activity_type)]
  out_dt[is.na(deaths_averted), deaths_averted := 0]
  
  cohort_dt <- wpp_input[age == 0, .(nx = sum(nx)), by = .(location_id, year)]
  setnames(cohort_dt, "nx", "cohort_size")
  out_dt <- merge(out_dt, cohort_dt, by = c("location_id", "year"))
  
  total_dt <- wpp_input[, .(nx = sum(nx)), by = .(location_id, year)]
  setnames(total_dt, "nx", "total_pop")
  out_dt <- merge(out_dt, total_dt, by = c("location_id", "year"))
  setcolorder(
    out_dt, 
    c(
      "location_name", "location_iso3", "location_id", "year", "disease", 
      "vaccine", "activity_type", "age", "impact_factor", "fvps", "deaths_averted",
      "region", "income_group", "gavi73", "cohort_size", "total_pop", paste0("draw_", 1:200)
    )
  )
  
  # Save results to file
  saveRDS(out_dt, file = paste0(o$pth$results, "reference_results.rds"))
}

# ---------------------------------------------------------
# Sample VIMC uncertainty using mean and sd from provided results
# Called by: run_uncertainty()
# ---------------------------------------------------------
generate_vimc_uncertainty = function (vimc_dt) {
  
  # Sample draws from normal distribution
  draws_dt = rnorm %>%  # Sample using normal distribution
    mapply(n    = o$n_draws, 
           mean = vimc_dt$deaths_averted, 
           sd   = vimc_dt$sd) %>%
    t() %>%  # One draw per column
    as_named_dt(paste0("draw_", 1 : o$n_draws))
  
  # Append draws to details 
  draws_wide = cbind(vimc_dt, draws_dt) %>%
    select(-sd)
  
  return(draws_wide)
}

# ---------------------------------------------------------
# Sample GBD uncertainty using initial efficacy confidence intervals
# Called by: run_uncertainty()
# ---------------------------------------------------------
generate_gbd_uncertainty = function(gbd_dt, scenario_impact) {
  
  # dt = tidyr::expand_grid(
  #     p1 = seq(log(1), log(10), length.out = 100), 
  #     p2 = seq(log(1), log(10), length.out = 100), 
  #     y  = NA) %>%
  #     as.data.table()
  
  # Initiate matrix (diseases x beta distribution parameters)
  opt_pars = matrix(NA, nrow = nrow(gbd_dt), ncol = 2)
  
  for (i in 1 : nrow(gbd_dt)) {
    
    # Vaccine efficacy details
    v = efficacy[i, .(mean, lower, upper)]
    
    # for (i in 1 : nrow(dt)) {
    #     dt$y[[i]] = obj_fn(unlist(dt[i, .(p1, p2)]), v)
    # }
    # 
    # g = ggplot(dt, aes(x = p1, y = p2, colour = y, fill = y)) + geom_point()
    
    # Determine ...
    opt_result = optim(par    = c(1, 1),     # Starting point
                       fn     = obj_fn,      # Objective function
                       data   = as.list(v),  # Additonal arguments for obj_fn
                       lower  = log(1), 
                       upper  = log(10),
                       method = "L-BFGS-B")
    
    opt_pars[i, ] = exp(opt_result$par)
  }
  
  # Draw samples from beta distribution using these optimal parameters
  draws_dt = opt_pars %>%
    as_named_dt(c("p1", "p2")) %>%
    # Sample from beta distribution...
    split(rownames(.)) %>%
    lapply(draw_fn, n = o$n_draws) %>%
    as_named_dt(efficacy$disease) %>%
    # Melt to long format...
    mutate(draw = paste0("draw_", 1 : o$n_draws)) %>%
    tidyr::pivot_longer(cols = -draw, 
                        names_to  = "disease", 
                        values_to = "scaler") %>%
    select(disease, draw, scaler) %>%
    arrange(disease) %>%
    as.data.table()
  
  # Join with reference results and apply scaler
  draws_wide = draws_dt %>%
    left_join(scenario_impact$dt, by = "disease") %>%
    mutate(deaths_averted_draw = deaths_averted * scaler) %>%
    select(-scaler) %>%
    tidyr::pivot_wider(names_from  = draw, 
                       values_from = deaths_averted_draw) %>%
    as.data.table()
  
  return(draws_wide)
}

# ---------------------------------------------------------
# Objective function to minimise
# ---------------------------------------------------------
obj_fn = function(par, data) {
  
  # Extract fitting parameters
  a = exp(par[1])
  b = exp(par[2])
  
  mean_diff = abs(a / (a + b) - data$mean)
  
  l_diff = abs(qbeta(0.05, a, b) - data$lower)
  u_diff = abs(qbeta(0.95, a, b) - data$upper)
  
  y = sum(c(20 * mean_diff, l_diff, u_diff))
  
  return(y)
}

# ---------------------------------------------------------
# Draw samples for beta distribution
# ---------------------------------------------------------
draw_fn = function(x, n) 
  rbeta(n, x$p1, x$p2) / (x$p1 / (x$p1 + x$p2))

