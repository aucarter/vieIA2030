###########################################################
# RELATIVE RISK
#
# Calculate relative risk given coverage details and deaths 
# averted. Then impute relative risk for missing locations
# using GBD covariates.
#
###########################################################

# ---------------------------------------------------------
# Parent function to impute relative risk for all disease-vaccine combinations
# Called by: launch.R, main.R (and other launch-style scripts)
# ---------------------------------------------------------
impute_all_rr <- function(params, routine_only = TRUE) {
  
  # Only continue if specified by do_step
  if (!is.element(1, o$do_step)) return()
  
  message("* Imputing relative risk")
  
  # TODO: Load all tables up front
  
  # Params generated by prep_params() - alpha and beta always 1 (unsure what these are actually doing)
  params <- jsonlite::fromJSON("params.json")  # Strcture: d, v, at, alpha, beta, age_knots
  
  # IDs of stratas to impute
  if (routine_only)
    strata_ids = d_v_at_table[activity_type == "routine"]$d_v_at_id
  
  # All stratas
  if (!routine_only)
    strata_ids = as.integer(names(params))
  
  # Calculate and impute relative risk for each strata
  pred_list = list()
  for (strata in strata_ids)
    pred_list[[strata]] = impute_strata_rr(strata, params)
  
  # Bind all stratas into single datatable
  pred_dt = rbindlist(pred_list, fill = TRUE)
  
  # Save relative risk calculations and predictions to file
  saveRDS(pred_dt, file = paste0(o$pth$rel_risk, "relative_risk.rds"))
  
  # return(pred_dt)  # No need to output now
}

# ---------------------------------------------------------
# Impute relative risk for a given disease-vaccine combination (aka strata)
# Called by: impute_all_rr()
# ---------------------------------------------------------
impute_strata_rr <- function(strata, params) {
  
  message(" - Strata: ", strata)
  
  # Details of this strata to be imputed
  strata_params <- params[[as.character(strata)]]
  
  # Prepare for relative risk calculation
  dt <- prep_rr(strata, strata_params)
  
  # Append location-specific covariates (eg social-economic index) from GBD
  dt <- merge_rr_covariates(dt)
  
  # Return trivial datatable if no valid relative risk results
  if (nrow(dt[rr > 0 & rr < 1]) == 0)
    return(data.table())
  
  # ---- Fit a model to predict relative risk ----
  
  # @Austin: Why binomial when predictor is continuous?
  
  # Fit a binomial GLM for relative risk using GBD covariates
  fit <- glm(formula = rr ~ haqi + sdi + year + mx + 
               splines::bs(age, knots = strata_params$age_knots),
             data    = dt[rr > 0 & rr < 1],
             family  = "binomial")
  
  # Predict relative risk
  dt[, pred := predict(fit, dt)]
  
  # Transform these predictions (?? Not sure what's happening here ??)
  # For floating point precision
  dt[, pred_rr := ifelse(pred > 0, 1 / (1 + exp(-pred)), exp(pred) / (exp(pred) + 1))]
  
  # Remove covariates
  dt[, c("pred", "haqi", "sdi", "mx") := NULL]
  dt[, d_v_at_id := strata]
  
  dt[, averted := get_averted_deaths(
    deaths_obs, coverage, pred_rr, strata_params$alpha)]
  
  return(dt)
}

# ---------------------------------------------------------
# Prepare relative risk calculation for given strata
# Called by: impute_strata_rr()
# ---------------------------------------------------------
prep_rr <- function(strata, strata_params) {
  
  # ---- Extract strata details ----
  
  # TODO: Feels verbose
  
  # Extract details about this disease, vaccine, and activity
  v  <- d_v_at_table[d_v_at_id == strata]$vaccine
  d  <- d_v_at_table[d_v_at_id == strata]$disease
  at <- d_v_at_table[d_v_at_id == strata]$activity_type
  
  # ID of this strata
  # @Austin - is v_at == strata always true?
  v_at <- v_at_table[vaccine == v & activity_type == at]$v_at_id
  
  # TEMP: Testing whether above line is needed
  if (v_at != strata)
    stop("Yep, previous line necessary")
  
  # Is this disease reported by VIMC? Otherwise GBD
  vimc <- disease_table[disease == d]$vimc == 1
  
  # ---- Load data ----
  
  # Load coverage and all cause death data
  load_tables("coverage", "all_deaths")  # See db_utils.R
  
  # TODO: Can we filter for strata here already?
  # TODO: Consistent order of columns and sorting (location_id, year, age, sex_id, ...)?
  
  # For VIMC diseases
  if (vimc) {
    
    # Load vaccine impact from VIMC
    load_tables("vimc_impact")  # See db_utils.R
    
    # Vaccine impact datatable - using VIMC estimates
    dt = copy(vimc_impact) %>%
      filter(d_v_at_id == strata) %>%  # Only this strata
      mutate(strata_deaths = NA, 
             sex_id        = 3) %>%  # ID of both genders combined
      select(location_id, year, age, sex_id, strata_deaths, 
             strata_deaths_averted = deaths_averted)
    
    # Sum deaths across each gender (datatable summarising much quicker)
    deaths = copy(all_deaths)[, .(deaths_obs = sum(deaths)), 
                              by = .(location_id, year, age)] %>%
      mutate(sex_id = 3, .before = deaths_obs)  # ID of both genders combined
  }
  
  # For GBD diseases
  if (!vimc) {
    
    # Load vaccine impact from GBD
    load_tables("gbd_strata_deaths")  # See db_utils.R
    
    browser()
    
    dt <- copy(gbd_strata_deaths)
    setnames(dt, "value", "strata_deaths")
    dt[, strata_deaths_averted := NA]
    
    # # Vaccine impact datatable - using VIMC estimates
    # dt = copy(gbd_strata_deaths) %>%
    #   rename(strata_deaths_averted = deaths_averted) %>%
    #   mutate(strata_deaths = NA, 
    #          sex_id        = 3)  # ID of both genders combined
    
    deaths <- copy(all_deaths)
    setnames(deaths, "deaths", "deaths_obs")
  }
  
  # Merge vaccine impact deaths with all cause observed deaths
  dt %<>% 
    right_join(deaths, by = c("location_id", "year", "age", "sex_id")) %>%
    mutate(d_v_at_id = strata, .after = location_id) %>%
    arrange(location_id, year, age)
  
  # ---- Total vaccine coverage by cohort ----
  
  # @Austin: I think total_coverage() should be handling the different activities. 
  # Meaning we shouldn't first filter by v_at_id. Thoughts?

  # xxxx
  # tot_cov = 
  x = coverage %>%
    filter(v_at_id == v_at, # TODO: Or just v_at_id == strata?
           year %in% o$analysis_years)
  
  tictoc::tic("v1")
  tot_cov = x %>% total_coverage()  # See total_coverage.R
  time_clock1 = tictoc::toc()
  
  # An attempt to make this calculation cleaner and faster...
  
  tictoc::tic("v2")
  tot_cov2 = x %>% total_coverage2()  # See total_coverage.R
  time_clock2 = tictoc::toc()
  
  check_dt = tot_cov2 %>%
    mutate(activity_type = at) %>%
    rename(value2 = value) %>%
    left_join(y  = tot_cov, 
              by = c("year", "age", "location_id", "sex_id", "vaccine", "activity_type")) %>%
    mutate(diff_value = abs(value - value2)) %>%
    filter(diff_value > 1e-8)
  
  if (nrow(check_dt) > 0)
    stop("Discrepancy between v1 and v2 functions")
  
  # Gender-related coverage issues...
  
  # @Austin: This feels like a big assumption, especially for vaccines like HPV, could we get
  # gender-specific outcomes from VIMC? Perhaps this is what you meant by your TODO comment?
  
  # TODO: This collapsing of sex should go away
  cov_dt <- tot_cov[, .(coverage = mean(value)),
                    by = .(location_id, year, age)]
  cov_dt[, sex_id := 3]
  
  if (!vimc) {
    cov_dt <- rbindlist(lapply(1:2, function(s) {
      copy(cov_dt)[, sex_id := s]
    }))
  }
  
  # Join coverage details to effect datatable
  dt <- merge(dt, cov_dt, by = c("location_id", "year", "age", "sex_id"),
              all = T)
  
  # ---- Calcualte relative risk ----
  
  # Calcualte relative risk: for VIMC diseases
  if (vimc)
    dt %<>% vimc_rr(strata_params$alpha)
  
  # Calcualte relative risk: for non-VIMC diseases
  if (!vimc)
    dt %<>% gbd_rr(strata_params$alpha, strata_params$beta, efficacy)
  
  # Reorder columns of output
  #
  # TODO: This shouldn't be necessary
  out_dt <- dt[, .(location_id, age, year, d_v_at_id, deaths_obs,
                   strata_deaths_averted, strata_deaths, coverage, rr)]
  
  # Perform sanity checks on relative risk calculations
  check_rr(out_dt)
  
  return(out_dt)
}

# ---------------------------------------------------------
# Calculate relative risk for VIMC disease
# Called by: prep_rr()
# ---------------------------------------------------------
vimc_rr <- function(dt, alpha) {
  
  # Relative risk tends to 1 as coverage tends to 1, can be negative
  #
  # rr = (o - (a * (1 - c ^ alpha) / c ^ alpha)) / (o + a)
  #
  # where:
  #   o = deaths observed
  #   a = deaths averted from vaccine
  #   c = coverage
  
  out_dt <- copy(dt)
  out_dt[coverage > 0, rr := (deaths_obs - (strata_deaths_averted *
                                              (1 - coverage ^ alpha) / coverage ^ alpha)) /
           (deaths_obs + strata_deaths_averted)]
  
  return(out_dt[])
}

# ---------------------------------------------------------
# Calculate relative risk for GBD disease
# Called by: prep_rr()
# ---------------------------------------------------------
gbd_rr <- function(dt, alpha, beta, efficacy) {
  
  browser()
  
  dt[, efficacy := efficacy[vaccine == v]$mean]  # Was in parent function
  
  out_dt <- copy(dt)
  out_dt[coverage > 0, deaths_no := strata_deaths /
           (1 - beta * efficacy * coverage ^ alpha)]
  out_dt[coverage > 0, rr :=
           (deaths_obs - strata_deaths + (1 - beta * efficacy) * deaths_no) /
           (deaths_obs - strata_deaths + deaths_no)]
  out_dt[, deaths_no := NULL]
  
  return(out_dt[])
}

# ---------------------------------------------------------
# Perform sanity checks on relative risk calculations
# Called by: prep_rr()
# ---------------------------------------------------------
check_rr <- function(dt) {
  
  # Look for missing coverage where deaths averted are non-zero
  if (nrow(dt[coverage == 0 & strata_deaths_averted > 0]) > 0) {
    
    # Proportion of cases
    prop <- round(nrow(dt[coverage == 0 & strata_deaths_averted > 0]) /
                    nrow(dt[strata_deaths_averted > 0]) * 100, 2)
    
    # Throw warning
    warning("Missing coverage in ", prop,
            "% of location-age-years with deaths averted")
  }
  
  # Check for non-sensical numbers
  if (any(range(dt[!is.na(rr)]$rr) < 0 | range(dt[!is.na(rr)]$rr) > 1)) {
    
    # Proportion of cases
    prop <- round(nrow(dt[coverage > 0 & (rr < 0 | rr > 1)]) /
                    nrow(dt) * 100, 2)
    
    # Throw warning
    warning("Over 1 or less than 0 mortality reduction in ", prop,
            "% of location-age-years")
  }
}

# ---------------------------------------------------------
# Append location-specific covariates (eg social-economic index) from GBD
# Called by: impute_strata_rr()
# ---------------------------------------------------------
merge_rr_covariates <- function(dt) {
  
  # @ Austin: several questions here (otherwise will read up)...
  #  1) What is 'mx' (and also 'nx', 'fx', and 'mig') in the world pop prospects data?
  #  2) How are SDI and HAQi metrics calculated?
  
  # NOTES:
  #  1) WWP stands for 'World Population Prospects'
  #  2) The MX in the WPP stands for ???
  #  3) Within the GBD (Global Burden of Disease) data
  #  a) HAQi stands for 'Healthcare Access and Quality index'
  #     See: https://www.healthdata.org/research-article/healthcare-access-and-quality-index-based-mortality-causes-amenable-personal-health
  #  b) SDI stands for 'Socio-demographic Index'
  #     See: https://www.healthdata.org/taxonomy/glossary/socio-demographic-index-sdi
  
  # All locations, years, and ages
  dt <- tidyr::expand_grid(
    location_id = unique(loc_table$location_id),
    age         = o$data_ages,
    year        = 2000 : 2095) %>% # ?? Why 2095?
    as.data.table() %>%
    merge(dt, by = c("location_id", "age", "year"), all.x = T)
  
  # Add mortality
  load_tables("wpp_input")  # See db_utils.R
  mx_dt <- wpp_input[, .(mx = mean(mx)), by = .(location_id, year, age)]
  dt <- merge(dt, mx_dt, by = c("location_id", "age", "year"), all.x = T)
  
  # Add GBD covariates (SDI and HAQi)
  dt <- merge(dt, gbd_cov, by = c("location_id",  "year"), all.x = T)
  
  return(dt)
}

# ---------------------------------------------------------
# xxxxx
# Called by: impute_strata_rr()
# ---------------------------------------------------------
get_averted_deaths <- function(deaths_obs, coverage, rr, alpha) {
  averted_deaths <- deaths_obs * (
    coverage ^ alpha * (1 - rr) / (1 - coverage ^ alpha * (1 - rr))
  )
  
  return(averted_deaths)
}

