###########################################################
# RELATIVE RISK
#
# Calculate relative risk given coverage details and deaths 
# averted. Then impute relative risk for missing locations
# using GBD covariates.
#
###########################################################

# ---------------------------------------------------------
# Parent function to impute relative risk for all disease-vaccine combinations
# Called by: launch.R, main.R (and other launch-style scripts)
# ---------------------------------------------------------
impute_all_rr <- function(routine_only = TRUE) {
  
  # Only continue if specified by do_step
  if (!is.element(1, o$do_step)) return()
  
  message("* Imputing relative risk")
  
  # Load all tables up front (see db_utils.R)
  load_tables("coverage", "all_deaths", "vimc_impact", "gbd_strata_deaths", "wpp_input")
  
  # Load strata parameters generated by prep_params()
  #
  # NOTE: alpha and beta always 1 (unsure what these are actually doing)
  all_params = jsonlite::fromJSON("params.json")  # Strcture: d, v, at, alpha, beta, age_knots
  
  # Filter out non-routinte activities if desired
  all_strata = d_v_at_table
  if (routine_only)
    all_strata %<>% filter(activity_type == "routine")
  
  # Shorthand for all strata IDs to work with
  strata_ids = all_strata$d_v_at_id
  
  # Calculate and impute relative risk for each strata
  #
  # NOTE: Result for each strata saved to file (in o$pth$rel_risk)
  lapply(strata_ids, function(id)
    impute_strata_rr(all_strata, all_params, id))
  
  message(" - Concatenating relative risk results")
  
  # Bind all stratas into single datatable
  rr_dt = lapply(strata_ids, load_rr) %>%
    rbindlist(fill = TRUE)
  
  # Save relative risk calculations and predictions to file
  saveRDS(rr_dt, file = paste0(o$pth$rel_risk, "relative_risk.rds"))
}

# ---------------------------------------------------------
# Impute relative risk for a given disease-vaccine combination (aka strata)
# Called by: impute_all_rr()
# ---------------------------------------------------------
impute_strata_rr <- function(all_strata, all_params, strata_id) {
  
  # Details of this strata
  strata = all_strata[d_v_at_id == strata_id]
  params = all_params[[strata_id]]
  
  # Display strata details
  message(" - Strata ID: ", strata_id,       "\n",
          "  > Disease: ",  strata$disease , "\n",
          "  > Vaccine: ",  strata$vaccine,  "\n", 
          "  > Activity: ", strata$activity_type)
  
  # Prepare for relative risk calculation
  dt <- prep_rr(strata, params)
  
  # Append location-specific covariates (eg social-economic index) from GBD
  dt <- merge_rr_covariates(dt)
  
  # Return trivial datatable if no valid relative risk results
  if (nrow(dt[rr > 0 & rr < 1]) == 0)
    return(data.table())
  
  # ---- Fit a model to predict relative risk ----
  
  # @Austin: Why binomial when predictor is continuous?
  
  # Fit a binomial GLM for relative risk using GBD covariates
  fit <- glm(formula = rr ~ haqi + sdi + year + mx + 
               splines::bs(age, knots = params$age_knots),
             data    = dt[rr > 0 & rr < 1],
             family  = "binomial")
  
  # Predict relative risk
  dt[, pred := predict(fit, dt)]
  
  # Transform these predictions (?? Not sure what's happening here ??)
  # For floating point precision
  dt[, pred_rr := ifelse(pred > 0, 1 / (1 + exp(-pred)), exp(pred) / (exp(pred) + 1))]
  
  # Remove covariates
  dt[, c("pred", "haqi", "sdi", "mx") := NULL]
  dt[, d_v_at_id := strata_id]
  
  # browser()  # This function is the inverse of vimc_rr() ??
  
  dt[, averted := get_averted_deaths(deaths_obs, coverage, pred_rr, params$alpha)]
  
  # Save result to file
  saveRDS(dt, file = paste0(o$pth$rel_risk, "relative_risk_id", strata_id, ".rds"))
}

# ---------------------------------------------------------
# Prepare relative risk calculation for given strata
# Called by: impute_strata_rr()
# ---------------------------------------------------------
prep_rr <- function(strata, params) {
  
  # ---- Extract strata details ----
  
  # Shorthand for strata ID
  strata_id = strata$d_v_at_id
  
  # Vaccine-actitvity ID
  #
  # NOTE: Not necessarily same as d_v_at_id (eg DTP3 single vaccine for multiple diseases)
  v_at_id = v_at_table %>% 
    filter(vaccine       == strata$vaccine, 
           activity_type == strata$activity_type) %>%
    pull(v_at_id)
  
  # Is this disease reported by VIMC? Otherwise GBD
  vimc <- disease_table[disease == strata$disease]$vimc == 1
  
  # ---- Load data ----
  
  # TODO: Consistent order of columns and sorting (location_id, year, age, sex_id, ...)?
  
  # For VIMC diseases
  if (vimc) {
    
    message("  > Impact source: VIMC")
    
    # Vaccine impact datatable - using VIMC estimates
    dt = copy(vimc_impact) %>%
      filter(d_v_at_id == strata_id) %>%  # Only this strata
      mutate(strata_deaths = NA, 
             sex_id        = 3) %>%  # ID of both genders combined
      select(location_id, year, age, sex_id, strata_deaths, 
             strata_deaths_averted = deaths_averted)
    
    # Sum deaths across each gender (datatable summarising much quicker)
    deaths = copy(all_deaths)[, .(deaths_obs = sum(deaths)), 
                              by = .(location_id, year, age)] %>%
      mutate(sex_id = 3, .before = deaths_obs)  # ID of both genders combined
  }
  
  # For GBD diseases
  if (!vimc) {
    
    message("  > Impact source: GBD")
    
    browser()
    
    dt <- copy(gbd_strata_deaths)
    setnames(dt, "value", "strata_deaths")
    dt[, strata_deaths_averted := NA]
    
    # # Vaccine impact datatable - using VIMC estimates
    # dt = copy(gbd_strata_deaths) %>%
    #   rename(strata_deaths_averted = deaths_averted) %>%
    #   mutate(strata_deaths = NA, 
    #          sex_id        = 3)  # ID of both genders combined
    
    deaths <- copy(all_deaths)
    setnames(deaths, "deaths", "deaths_obs")
  }
  
  # Merge vaccine impact deaths with all cause observed deaths
  dt %<>% 
    right_join(deaths, by = c("location_id", "year", "age", "sex_id")) %>%
    mutate(d_v_at_id = strata_id, .after = location_id) %>%
    arrange(location_id, year, age)
  
  # ---- Total vaccine coverage by cohort ----
  
  # @Austin: I think total_coverage() should be handling the different activities. 
  # Meaning we shouldn't first filter by v_at_id. Thoughts?

  # xxxx
  # tot_cov = 
  strata_cov = coverage %>%
    filter(v_at_id == !!v_at_id,  # Coverage is per vaccine, not per strata
           year %in% o$analysis_years)
  
  # Total coverage: version 1
  tictoc::tic("v1")
  tot_cov = strata_cov %>% total_coverage()  # See total_coverage.R
  time_clock1 = tictoc::toc()
  
  # An attempt to make this calculation cleaner and faster...
  
  # Total coverage: version 2
  tictoc::tic("v2")
  tot_cov2 = strata_cov %>% total_coverage2()  # See total_coverage.R
  time_clock2 = tictoc::toc()
  
  # Check these are identical...
  check_dt = tot_cov2 %>%
    mutate(activity_type = strata$activity_type) %>%
    rename(value2 = value) %>%
    left_join(y  = tot_cov, 
              by = c("year", "age", "location_id", "sex_id", "vaccine", "activity_type")) %>%
    mutate(diff_value = abs(value - value2)) %>%
    filter(diff_value > 1e-8)
  
  # Throw an error if any clear
  if (nrow(check_dt) > 0)
    stop("Discrepancy between v1 and v2 functions")
  
  # Gender-related coverage issues...
  
  # @Austin: This feels like a big assumption, especially for vaccines like HPV, could we get
  # gender-specific outcomes from VIMC? Perhaps this is what you meant by your TODO comment?
  
  # TODO: This collapsing of sex should go away
  cov_dt <- tot_cov[, .(coverage = mean(value)),
                    by = .(location_id, year, age)]
  cov_dt[, sex_id := 3]
  
  if (!vimc) {
    cov_dt <- rbindlist(lapply(1:2, function(s) {
      copy(cov_dt)[, sex_id := s]
    }))
  }
  
  # Join coverage details to effect datatable
  dt <- merge(dt, cov_dt, by = c("location_id", "year", "age", "sex_id"),
              all = T)
  
  # ---- Calcualte relative risk ----
  
  # Calcualte relative risk: for VIMC diseases
  if (vimc)
    dt %<>% vimc_rr(params$alpha)
  
  # Calcualte relative risk: for non-VIMC diseases
  if (!vimc)
    dt %<>% gbd_rr(params$alpha, params$beta, efficacy)
  
  # Reorder columns of output
  #
  # TODO: This shouldn't be necessary
  out_dt <- dt[, .(location_id, age, year, d_v_at_id, deaths_obs,
                   strata_deaths_averted, strata_deaths, coverage, rr)]
  
  # Perform sanity checks on relative risk calculations
  check_rr(out_dt)
  
  return(out_dt)
}

# ---------------------------------------------------------
# Calculate relative risk for VIMC disease
# Called by: prep_rr()
# ---------------------------------------------------------
vimc_rr <- function(dt, alpha) {
  
  # Relative risk tends to 1 as coverage tends to 1, could be negative
  #
  # rr = (o - (a * (1 - c^alpha) / c^alpha)) / (o + a)
  #
  # where:
  #   o = deaths observed
  #   a = deaths averted from vaccine
  #   c = coverage
  
  out_dt <- copy(dt)
  out_dt[coverage > 0, rr := (deaths_obs - (strata_deaths_averted *
                                              (1 - coverage ^ alpha) / coverage ^ alpha)) /
           (deaths_obs + strata_deaths_averted)]
  
  return(out_dt[])
}

# ---------------------------------------------------------
# Calculate relative risk for GBD disease
# Called by: prep_rr()
# ---------------------------------------------------------
gbd_rr <- function(dt, alpha, beta, efficacy) {
  
  browser()
  
  dt[, efficacy := efficacy[vaccine == v]$mean]  # Was in parent function
  
  out_dt <- copy(dt)
  out_dt[coverage > 0, deaths_no := strata_deaths /
           (1 - beta * efficacy * coverage ^ alpha)]
  out_dt[coverage > 0, rr :=
           (deaths_obs - strata_deaths + (1 - beta * efficacy) * deaths_no) /
           (deaths_obs - strata_deaths + deaths_no)]
  out_dt[, deaths_no := NULL]
  
  return(out_dt[])
}

# ---------------------------------------------------------
# Perform sanity checks on relative risk calculations
# Called by: prep_rr()
# ---------------------------------------------------------
check_rr <- function(dt) {
  
  # Look for missing coverage where deaths averted are non-zero
  if (nrow(dt[coverage == 0 & strata_deaths_averted > 0]) > 0) {
    
    # Proportion of cases
    prop <- round(nrow(dt[coverage == 0 & strata_deaths_averted > 0]) /
                    nrow(dt[strata_deaths_averted > 0]) * 100, 2)
    
    # Throw warning
    warning("Missing coverage in ", prop,
            "% of location-age-years with deaths averted")
  }
  
  # Check for non-sensical numbers
  if (any(range(dt[!is.na(rr)]$rr) < 0 | range(dt[!is.na(rr)]$rr) > 1)) {
    
    # Proportion of cases
    prop <- round(nrow(dt[coverage > 0 & (rr < 0 | rr > 1)]) /
                    nrow(dt) * 100, 2)
    
    # Throw warning
    warning("Over 1 or less than 0 mortality reduction in ", prop,
            "% of location-age-years")
  }
}

# ---------------------------------------------------------
# Function for loading relative risk of a strata
# Called by: impute_all_rr()
# ---------------------------------------------------------
load_rr = function(id) {
  
  # Attempt to load relative risk result for this strata
  strata_rr = try_load(pth  = o$pth$rel_risk, 
                       file = paste0("relative_risk_id", id), 
                       throw_error = FALSE)  # Set to FALSE to throw only an error
  
  return(strata_rr)
}

# ---------------------------------------------------------
# Append location-specific covariates (eg social-economic index) from GBD
# Called by: impute_strata_rr()
# ---------------------------------------------------------
merge_rr_covariates <- function(dt) {
  
  # @ Austin: several questions here (otherwise will read up)...
  #  1) What is 'mx' (and also 'nx', 'fx', and 'mig') in the world pop prospects data?
  #  2) How are SDI and HAQi metrics calculated?
  
  # NOTES:
  #  1) WWP stands for 'World Population Prospects'
  #  2) The MX in the WPP stands for ???
  #  3) Within the GBD (Global Burden of Disease) data
  #  a) HAQi stands for 'Healthcare Access and Quality index'
  #     See: https://www.healthdata.org/research-article/healthcare-access-and-quality-index-based-mortality-causes-amenable-personal-health
  #  b) SDI stands for 'Socio-demographic Index'
  #     See: https://www.healthdata.org/taxonomy/glossary/socio-demographic-index-sdi
  
  # All locations, years, and ages
  dt <- tidyr::expand_grid(
    location_id = unique(loc_table$location_id),
    age         = o$data_ages,
    year        = 2000 : 2095) %>% # ?? Why 2095?
    as.data.table() %>%
    merge(dt, by = c("location_id", "age", "year"), all.x = T)
  
  # Add mortality
  mx_dt <- wpp_input[, .(mx = mean(mx)), by = .(location_id, year, age)]
  dt <- merge(dt, mx_dt, by = c("location_id", "age", "year"), all.x = T)
  
  # Add GBD covariates (SDI and HAQi)
  dt <- merge(dt, gbd_cov, by = c("location_id",  "year"), all.x = T)
  
  return(dt)
}

# ---------------------------------------------------------
# Extract averted deaths from relative risk equation
# Called by: impute_strata_rr()
# ---------------------------------------------------------
get_averted_deaths <- function(deaths_obs, coverage, rr, alpha) {
  
  # rr = (o - (a * (1 - c^alpha) / c^alpha)) / (o + a)
  #
  # => a = (o * (1 - rr) * c^alpha) / (1 + (rr - 1) * c^alpha)
  #
  # where:
  #   o = deaths observed
  #   a = deaths averted from vaccine
  #   c = coverage
  
  averted_deaths <- deaths_obs * (coverage ^ alpha * (1 - rr) / 
                                    (1 - coverage ^ alpha * (1 - rr)))
  
  return(averted_deaths)
}

